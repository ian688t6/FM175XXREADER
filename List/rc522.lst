C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE RC522
OBJECT MODULE PLACED IN .\Output\rc522.obj
COMPILER INVOKED BY: E:\Tools\Keil5\C51\BIN\C51.EXE rc522.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Inc) DEBUG OBJECTEXT
                    -END PRINT(.\List\rc522.lst) OBJECT(.\Output\rc522.obj)

line level    source

   1          #include <intrins.h>
   2          #include "STC15F2K60S2.h"
   3          #include "main.h"
   4          #include "rc522.h"
   5          #include "spi.h"
   6          #include "uart.h"
   7          #include <string.h>
   8          
   9          #define u8 unsigned char
  10          #define u16 unsigned int
  11          
  12          u8 fcnt;                                //ÏìÓ¦Ê±¼ä
  13          unsigned char idata PCB = 0x0A;                                 //CPU¿¨APDUÖ¸Áî·Ö×éºÅ
  14          
  15          void delay_us(unsigned int x)
  16          {
  17   1              while(x)
  18   1              {
  19   2                      _nop_();
  20   2                      x--;
  21   2              }
  22   1                      
  23   1      }
  24          
  25                                                          
  26          //*************************************************************************
  27          // º¯ÊýÃû       £ºRC522_Init
  28          // ÃèÊö         £º³õÊ¼»¯Òý½Å
  29          // Èë¿Ú         £ºÎÞ
  30          // ³ö¿Ú         £ºÎÞ
  31          // ·µ»Ø         £ºÎÞ
  32          //*************************************************************************
  33          void RC522_Init(void)
  34          {               
  35   1              PcdReset();
  36   1              PcdConfigISOType('A');
  37   1              fcnt = 0;
  38   1      }
  39          
  40          //*************************************************************************
  41          // º¯ÊýÃû       £ºPcdSwitchPCB(void)
  42          // ÃèÊö         £ºÇÐ»»·Ö×éºÅ
  43          // Èë¿Ú         £º
  44          // ³ö¿Ú         £º
  45          // ·µ»Ø         £º³É¹¦·µ»ØMI_OK
  46          //*************************************************************************
  47          
  48          void PcdSwitchPCB(void)
  49          {
  50   1              Send_char1('P');Send_char1('c');Send_char1('b');Send_char1(':');
  51   1              Hex_Print(PCB);
  52   1              Send_char1('\r');Send_char1('\n');
  53   1              switch(PCB)
  54   1              {
C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 2   

  55   2                      case 0x00:
  56   2                              PCB=0x0A;
  57   2                              break;
  58   2                      case 0x0A:
  59   2                              PCB=0x0B;
  60   2                              break;
  61   2                      case 0x0B:
  62   2                              PCB=0x0A;
  63   2                              break;
  64   2                      default:
  65   2                              PCB=0x0A;
  66   2                              break;
  67   2              }
  68   1      }
  69          
  70          //*************************************************************************
  71          // º¯ÊýÃû       £ºPcdConfigISOType(u8 type)
  72          // ÃèÊö         £ºÉèÖÃRC522µÄ¹¤×÷·½Ê½
  73          // Èë¿Ú         £ºtype[IN]:¿¨Æ¬ÀàÐÍ
  74          // ³ö¿Ú         £ºÎÞ
  75          // ·µ»Ø         £º³É¹¦·µ»ØMI_OK
  76          //*************************************************************************
  77          s8 PcdConfigISOType(u8 type)
  78          {       
  79   1              s8 status = MI_ERR;
  80   1              if(type == 'A')
  81   1              {
  82   2                      status = MI_OK;
  83   2                      ClearBitMask(Status2Reg,0x08);  //×´Ì¬2¼Ä´æÆ÷
  84   2                      WriteRawRC(ModeReg,0x3D);                       //ºÍMifare¿¨Í¨Ñ¶,CRC³õÊ¼Öµ0x6363
  85   2                      WriteRawRC(RxSelReg,0x86);              //Ñ¡ÔñÄÚ²¿½ÓÊÕÆ÷ÉèÖÃ,ÄÚ²¿Ä£Äâ²¿·Öµ÷ÖÆÐÅºÅ,·¢ËÍÊý¾Ýºó,ÑÓÊ±6¸öÎ»Ê±ÖÓ,½ÓÊÕ  10
  86   2                      WriteRawRC(RFCfgReg,0x7F);              //ÅäÖÃ½ÓÊÕÆ÷,48dB×î´óÔöÒæ  
  87   2                  WriteRawRC(TReloadRegL,0x30);       //¶¨Ê±Æ÷µÄµÍ8Î»Êý¾Ý 
  88   2                  WriteRawRC(TReloadRegH,0x00);               //¶¨Ê±Æ÷µÄ¸ß8Î»Êý¾Ý,Êµ¼ÊÖµÊÇ0xD3EÕâ²¿·ÖÖ÷ÒªÊÇÉèÖÃ¶¨Ê±Æ÷¼Ä´æÆ÷
  89   2              WriteRawRC(TModeReg,0x8D);              //Êµ¼ÊÖµÊÇ0X0D3EÕâ²¿·ÖÖ÷ÒªÊÇÉèÖÃ¶¨Ê±Æ÷¼Ä´æÆ÷TPrescaler ·ÖÆµÊýÎª0xD0       //
             -8D
  90   2                      WriteRawRC(TPrescalerReg,0x3E); 
  91   2                      delay_us(1000);
  92   2                      PcdAntennaOn();
  93   2              }
  94   1              return status;
  95   1      }
  96          
  97          //*************************************************************************
  98          // º¯ÊýÃû       £ºWriteRawRC
  99          // ÃèÊö         £ºÐ´RC522¼Ä´æÆ÷
 100          // Èë¿Ú         £ºAddress[IN]:¼Ä´æÆ÷µØÖ·
 101          //                        value:Ð´ÈëÊýÖµ
 102          // ³ö¿Ú         £ºÎÞ
 103          // ·µ»Ø         £ºÎÞ
 104          //*************************************************************************
 105          void WriteRawRC(u8 Address, u8 value)
 106          {  
 107   1          u8 i, ucAddr;
 108   1      
 109   1          SCK = 0;
 110   1          NSS = 0;
 111   1          ucAddr = ((Address<<1)&0x7E);
 112   1      
 113   1          for(i=0;i<8;i++)                                                            //ÏÈ·¢ËÍµØÖ·
 114   1          {    
 115   2                      MOSI = ((ucAddr&0x80)==0x80);
C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 3   

 116   2              SCK = 1;
 117   2              ucAddr <<= 1;
 118   2              SCK = 0;           
 119   2          }
 120   1      
 121   1          for(i=0;i<8;i++)
 122   1          {   
 123   2              MOSI = ((value&0x80)==0x80);                            //ÔÙ·¢ËÍ²Ù×÷Êý
 124   2              SCK = 1;
 125   2              value <<= 1;
 126   2              SCK = 0;
 127   2          }
 128   1          NSS = 1;
 129   1          SCK = 1;
 130   1      }
 131          //*************************************************************************
 132          // º¯ÊýÃû       £ºReadRawRC
 133          // ÃèÊö         £º¶ÁRC522¼Ä´æÆ÷
 134          // Èë¿Ú         £ºAddress[IN]:¼Ä´æÆ÷µØÖ·
 135          // ³ö¿Ú         £ºÎÞ
 136          // ·µ»Ø         £º¶Á³öµÄÖµ
 137          //*************************************************************************
 138          u8 ReadRawRC(u8 Address)
 139          {
 140   1      
 141   1           u8 i, ucAddr;
 142   1           u8 ucResult=0;
 143   1      
 144   1           SCK = 0;
 145   1           NSS = 0;
 146   1           ucAddr = ((Address<<1)&0x7E)|0x80; 
 147   1      
 148   1           for(i=0;i<8;i++)
 149   1           {
 150   2                      MOSI = ((ucAddr&0x80)==0x80);
 151   2                      SCK = 1;
 152   2                      ucAddr <<= 1;
 153   2                      SCK = 0;
 154   2           }
 155   1      
 156   1           for(i=0;i<8;i++)
 157   1           {
 158   2                      SCK = 1;
 159   2                      ucResult <<= 1;
 160   2                      ucResult|=MISO&0x01;
 161   2                      SCK = 0;
 162   2           }
 163   1      
 164   1           NSS = 1;
 165   1           SCK = 1;
 166   1           return ucResult;
 167   1      }
 168          
 169          //*************************************************************************
 170          // º¯ÊýÃû       £ºSetBitMask
 171          // ÃèÊö         £ºÎ»ÖÃ1
 172          // Èë¿Ú         £ºreg[IN]:¼Ä´æÆ÷µØÖ·
 173          //                        mask[IN]:ÖÃÎ»Öµ
 174          // ³ö¿Ú         £ºÎÞ
 175          // ·µ»Ø         £ºÎÞ
 176          //*************************************************************************
 177          void SetBitMask(u8 reg,u8 mask)  
C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 4   

 178          {
 179   1          u8 tmp = 0x0;
 180   1          tmp = ReadRawRC(reg);
 181   1          WriteRawRC(reg,tmp | mask);  // set bit mask
 182   1      }
 183          
 184          //*************************************************************************
 185          // º¯ÊýÃû       £ºClearBitMask
 186          // ÃèÊö         £ºÎ»ÖÃ0
 187          // Èë¿Ú         £ºreg[IN]:¼Ä´æÆ÷µØÖ·
 188          //                        mask[IN]:ÖÃÎ»Öµ
 189          // ³ö¿Ú         £ºÎÞ
 190          // ·µ»Ø         £ºÎÞ
 191          //*************************************************************************
 192          void ClearBitMask(u8 reg,u8 mask)  
 193          {
 194   1          u8 tmp = 0x00;
 195   1          tmp = ReadRawRC(reg);
 196   1          WriteRawRC(reg, tmp & ~mask);                                               // clear bit mask
 197   1      } 
 198          //*************************************************************************
 199          // º¯ÊýÃû       £ºPcdAntennaOff
 200          // ÃèÊö         £º¹Ø±ÕÌìÏß
 201          // Èë¿Ú         £ºÎÞ
 202          // ³ö¿Ú         £ºÎÞ
 203          // ·µ»Ø         £ºÎÞ
 204          //*************************************************************************
 205          void PcdAntennaOff(void)
 206          {
 207   1          ClearBitMask(TxControlReg, 0x03);                                   //½ûÖ¹Tx1RFEn,Tx2RFEn
 208   1      }
 209          
 210          //*************************************************************************
 211          // º¯ÊýÃû       £ºPcdAntennaOn  
 212          // ÃèÊö         £º¿ªÆôÌìÏß,Ã¿´ÎÆô¶¯»ò¹Ø±ÕÌìÏÕ·¢ÉäÖ®¼äÓ¦ÖÁÉÙÓÐ1msµÄ¼ä¸ô
 213          // Èë¿Ú         £ºÎÞ
 214          // ³ö¿Ú         £ºÎÞ
 215          // ·µ»Ø         £ºÎÞ
 216          //*************************************************************************
 217          void PcdAntennaOn(void)
 218          {
 219   1          unsigned char i;
 220   1          i = ReadRawRC(TxControlReg);                                                //¶ÁÈ¡³ö·¢ËÍ¿ØÖÆ¼Ä´æÆ÷
 221   1          if (!(i & 0x03))                                                                    //Èç¹ûÎ´¿ªÆô,Ôò
 222   1          {
 223   2              SetBitMask(TxControlReg, 0x03);                                 //¿ªÆôTx1RFEn,Tx2RFEn
 224   2          }
 225   1      }
 226          
 227          //*************************************************************************
 228          // º¯ÊýÃû       £ºPcdComMF522  
 229          // ÃèÊö         £ºÍ¨¹ýRC522ºÍISO14443¿¨Í¨Ñ¶
 230          // Èë¿Ú         £ºCommand[IN]:RC522ÃüÁî×Ö
 231          //                        pDataIn[IN]:Í¨¹ýRC522·¢ËÍµ½¿¨Æ¬µÄÊý¾Ý
 232          //                        InLenByte[IN]:·¢ËÍÊý¾ÝµÄ×Ö½Ú³¤¶È
 233          //                        *pOutLenBit[OUT]:·µ»ØÊý¾ÝµÄÎ»³¤¶È
 234          // ³ö¿Ú         £ºpDataOut[OUT]:½ÓÊÕµ½µÄ¿¨Æ¬·µ»ØÊý¾Ý
 235          // ·µ»Ø         £ºÎÞ
 236          //*************************************************************************
 237          s8 PcdComMF522(u8 Command, u8 *pDataIn, u8 InLenByte, u8 *pDataOut, u16  *pOutLenBit)
 238          {
 239   1          s8 status = MI_ERR;
C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 5   

 240   1          u8 irqEn   = 0x00;
 241   1          u8 waitFor = 0x00;
 242   1          u8 lastBits;
 243   1          u8 n;
 244   1          u16 i;
 245   1          switch(Command)
 246   1          {
 247   2             case PCD_AUTHENT:
 248   2                irqEn   = 0x12;
 249   2                waitFor = 0x10;
 250   2                break;
 251   2             case PCD_TRANSCEIVE:
 252   2                irqEn   = 0x77;
 253   2                waitFor = 0x30;                                                       // ½ÓÊÜµ½Êý¾Ý¼°ÃüÁîÖ´ÐÐÍê±Ï     
 254   2                break;
 255   2             default:
 256   2               break;
 257   2          }
 258   1          WriteRawRC(ComIEnReg,irqEn|0x80);                       // ÈÝÐí³ý¶¨Ê±Æ÷ÖÐ¶ÏÇëÇóÒÔÎªµÃËùÓÐÖÐ¶ÏÇëÇó
 259   1          ClearBitMask(ComIrqReg,0x80);                                       // ÆÁ±ÎÎ»Çå³ý
 260   1          WriteRawRC(CommandReg,PCD_IDLE);                            // È¡Ïûµ±Ç°ÃüÁî
 261   1          SetBitMask(FIFOLevelReg,0x80);                                      // Çå³ýFIFOÖÐµÄ¶ÁÐ´Ö¸Õë
 262   1      
 263   1          for (i=0; i<InLenByte; i++)
 264   1          {   
 265   2                      WriteRawRC(FIFODataReg, pDataIn[i]);                    //Êý¾ÝÐ´ÈëFIFO
 266   2              }
 267   1          WriteRawRC(CommandReg, Command);                                    //Ð´ÈëÃüÁî,½«»º³åÇøÖÐµÄÊý¾Ý·¢ËÍµ½ÌìÏß,²¢¼¤»î×Ô¶¯½ÓÊÕÆ÷
 268   1         
 269   1          if (Command == PCD_TRANSCEIVE)                                              //Èç¹ûÃüÁîÎª0C
 270   1          {    
 271   2                      SetBitMask(BitFramingReg,0x80);                                 //Ïàµ±ÓÚÆô¶¯·¢ËÍSTARTSENG
 272   2              }
 273   1          i = 2000;                                                                                   //¸ù¾ÝÊ±ÖÓÆµÂÊµ÷Õû£¬²Ù×÷M1¿¨×î´óµÈ´ýÊ±¼ä=600,²Ù×÷CPU¿¨×î´óµÈ´ýÊ±¼ä=1200
 274   1              do 
 275   1          {
 276   2               n = ReadRawRC(ComIrqReg);                                              //¶ÁÈ¡ÖÐ¶Ï±êÖ¾,¼ì²éÊý¾Ý·µ»Ø
 277   2               i--;
 278   2          }
 279   1          while ((i!=0) && !(n&0x20) && !(n&waitFor));                // ¶¨Ê±Æ÷Î´³¬Ê±,Ã»ÓÐ´íÎó,0x01,0x30
 280   1          ClearBitMask(BitFramingReg,0x80);                                   // Ïàµ±ÓÚÇå³ý·¢ËÍSTARTSENG
 281   1      
 282   1          if (i!=0)                                                                                   // ¶¨Ê±Ê±¼äµ½£¬i£¬Ã»ÓÐµÝ¼õµ½0
 283   1          {    
 284   2               if(!(ReadRawRC(ErrorReg)&0x1B))                                // ÅÐ¶ÏÓÐÎÞ³öÏÖ´íÎó±êÖ¾  BufferÒç³ö,Î»³åÍ»,½ÓÊÕCRC´íÎó,ÆæÅ¼Ð£Ñ
             -é´íÎó,
 285   2               {      
 286   3                   status = MI_OK;                                                    // ³õÊ¼»¯×´Ì¬ 
 287   3                               if (n & irqEn & 0x01)                                          // ÈôÊÇPCD_TRANSCEIVE, irq = 0x77,  ¶¨Ê±Æ÷Îª0ÖÐ¶Ï²úÉú,¶¨Ê±Æ÷Îª0Ê±Îª´íÎó
 288   3                               {   
 289   4                                      status = MI_NOTAGERR;                                   // ËÑË÷²»µ½¿¨
 290   4                               }
 291   3                   if (Command == PCD_TRANSCEIVE)                             // Èç¹ûÊÇ·¢ËÍ½ÓÊÕÖ¸Áî
 292   3                   { 
 293   4                      n = ReadRawRC(FIFOLevelReg);                    // ¶ÁÈ¡½ÓÊÕµ½µÄÊý¾ÝµÄ×Ö½ÚÊý
 294   4                      lastBits = ReadRawRC(ControlReg) & 0x07;// 2-0:RxLastBits,ÏÔÊ¾½ÓÊÕµ½×îºóÒ»¸ö×Ö½ÚµÄÎ»Êý
 295   4                      if (lastBits)                                                   // Èô¸ÃÎ»Îª0£¬×îºóÕû¸ö×Ö½ÚÓÐÐ§
 296   4                      {   
 297   5                                              *pOutLenBit = (n-1)*8 + lastBits;   //pOutLenBit¼ÇÂ¼×Ü¹²ÊÕµ½µÄÎ»Êý
 298   5                                      }
 299   4                      else
 300   4                      {   
C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 6   

 301   5                                              *pOutLenBit = n*8;                              //½ÓÊÕÍêÕûÎ»Êý
 302   5                                      }
 303   4                      if (n == 0)                                                             //¼ÙÈçÃ»ÓÐÖÐ¶Ï²úÉú
 304   4                      {   
 305   5                                              n = 1;                                                          //nÖÃ1
 306   5                                      }
 307   4                      if (n > MAXRLEN)                                                // Ò»´Î×î´óÄÜ½ÓÊÜµ½µÄ×Ö½ÚÊý
 308   4                      {   
 309   5                                              n = MAXRLEN;                                            //³¬³ö×î´ó³¤¶È,Ö»½ÓÊÜ×î´ó³¤¶ÈµÄÖµ
 310   5                                      }
 311   4                      for (i=0; i<n; i++)
 312   4                      {   
 313   5                                              pDataOut[i] = ReadRawRC(FIFODataReg); //´ÓFIFO¶ÁÈ¡Êý¾Ý   
 314   5                                      }
 315   4                  }
 316   3               }
 317   2               else
 318   2               {   
 319   3                              status = MI_ERR;                                                        //ÓÐ´íÎó
 320   3                       }
 321   2         }
 322   1         SetBitMask(ControlReg,0x80);                 //Í£Ö¹¶¨Ê±Æ÷
 323   1         WriteRawRC(CommandReg,PCD_IDLE);             //Çå¿ÕÖ¸Áî
 324   1         return status;                                                               //·µ»Ø×´Ì¬
 325   1      } 
 326          
 327          //*************************************************************************
 328          // º¯ÊýÃû       £ºPcdReset
 329          // ÃèÊö         £º¸´Î»RC522
 330          // Èë¿Ú         £ºÎÞ
 331          // ³ö¿Ú         £ºÎÞ
 332          // ·µ»Ø         £º³É¹¦·µ»ØMI_OK
 333          //*************************************************************************
 334          s8 PcdReset(void)
 335          {
 336   1          MFRST=0;
 337   1              P16 = 0;
 338   1              delay_us(1000);
 339   1          MFRST=1;
 340   1              P16 = 1;
 341   1              delay_us(1000);
 342   1          WriteRawRC(CommandReg,PCD_RESETPHASE);
 343   1          delay_us(100);
 344   1              WriteRawRC(ModeReg,0x3D);               //ºÍMifare¿¨Í¨Ñ¶£¬CRC³õÊ¼Öµ0x6363
 345   1          WriteRawRC(TModeReg,0x8D);                          //¶¨Ê±Æ÷Ä£Ê½¼Ä´æÆ÷,¶¨Ê±Æ÷¼õÖµ¼ÆÊý
 346   1          WriteRawRC(TReloadRegL,0x30);               //¶¨Ê±Æ÷µÄµÍ8Î»Êý¾Ý 
 347   1          WriteRawRC(TReloadRegH,0x00);                       //¶¨Ê±Æ÷µÄ¸ß8Î»Êý¾Ý
 348   1          WriteRawRC(TPrescalerReg,0x3E);                     //Êµ¼ÊÖµÊÇ0X0D3EÕâ²¿·ÖÖ÷ÒªÊÇÉèÖÃ¶¨Ê±Æ÷¼Ä´æÆ÷
 349   1              WriteRawRC(TxAutoReg,0x40);                             //±ØÐëÒª,ÉèÖÃÂß¼­1,Ç¿ÖÆ100%ASKµ÷ÖÆ
 350   1              PCB=0x00;
 351   1          return MI_OK;                                                       //¶¨Ê±Æ÷Ê±¼ä6.78M/TPrescaler(ms)
 352   1      }
 353          
 354          //*************************************************************************
 355          // º¯ÊýÃû       £ºCalulateCRC
 356          // ÃèÊö         £ºÓÃMF522¼ÆËãCRC16º¯Êý
 357          // Èë¿Ú         £ºpIndata[IN]:ÐèÒª¼ÆËãµÄÊý¾Ý
 358          //                        len[IN]:Êý¾Ý³¤¶È
 359          // ³ö¿Ú         £ºpDataOut[OUT]:Êä³ö½á¹ûµÄÁ½¸ö×Ö½ÚÊý×é
 360          // ·µ»Ø         £ºÎÞ
 361          //*************************************************************************
 362          void CalulateCRC(u8 *pIndata,u8 len,u8 *pDataOut)
C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 7   

 363          {
 364   1          u8 i,n;
 365   1          ClearBitMask(DivIrqReg,0x04);
 366   1          WriteRawRC(CommandReg,PCD_IDLE);   //È¡Ïûµ±Ç°ÃüÁî
 367   1          SetBitMask(FIFOLevelReg,0x80);         //FlushBuffer Çå³ýErrReg µÄ±êÖ¾Î»
 368   1          for (i=0; i<len; i++)
 369   1              WriteRawRC(FIFODataReg, *(pIndata+i));
 370   1          WriteRawRC(CommandReg, PCD_CALCCRC);
 371   1          i = 0xFF;
 372   1          do 
 373   1          {
 374   2              n = ReadRawRC(DivIrqReg);
 375   2              i--;
 376   2          }
 377   1          while ((i!=0) && !(n&0x04));                //µ±CRCIRq ËùÓÐÊý¾Ý±»´¦ÀíÍê±Ï¸ÃÎ»ÖÃÎ»
 378   1          pDataOut[0] = ReadRawRC(CRCResultRegL);
 379   1          pDataOut[1] = ReadRawRC(CRCResultRegM);
 380   1      }
 381          
 382          
 383          //*************************************************************************
 384          // º¯ÊýÃû       £ºPcdSelect
 385          // ÃèÊö         £ºÑéÖ¤¿¨Æ¬ÃÜÂë
 386          // Èë¿Ú         £ºpSnr[IN]:¿¨Æ¬ÐòÁÐºÅ£¬4×Ö½Ú
 387          // ³ö¿Ú         £ºÎÞ
 388          // ·µ»Ø         £º³É¹¦·µ»ØMI_OK
 389          //*************************************************************************
 390          s8 PcdSelect(u8 *pSnr)
 391          {
 392   1          s8 status;
 393   1          u8 i;
 394   1          u16 unLen;
 395   1          u8 ucComMF522Buf[MAXRLEN];          
 396   1          
 397   1          ClearBitMask(Status2Reg,0x08);                              // Çå¿ÕÐ£Ñé³É¹¦±êÖ¾     
 398   1      
 399   1              memset(ucComMF522Buf, 0x00, MAXRLEN);
 400   1      
 401   1          ucComMF522Buf[0] = PICC_ANTICOLL1;                          // ·À³åÍ»
 402   1          ucComMF522Buf[1] = 0x70;                                            // ·¢ËÍ7×Ö½Ú 
 403   1          ucComMF522Buf[6] = 0;                                                       //IDÐ£ÑéÇå0
 404   1          for (i=0; i<4; i++)
 405   1          {
 406   2              ucComMF522Buf[i+2] = *(pSnr+i);                         // ±£´æ¿¨ID
 407   2              ucComMF522Buf[6]  ^= *(pSnr+i);                         // ¼ÆËãÐ£ÑéÖµ
 408   2          }
 409   1          CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);     // Éú³É·¢ËÍÄÚÈÝµÄCRCÐ£Ñé,±£´æµ½×îºóÁ½¸ö×Ö½Ú
 410   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);  // ·¢ËÍÑ¡¿¨,¼°CRCÐ£Ñé
 411   1          
 412   1          if ((status != MI_OK) || (unLen != 0x18))           // ·µ»Ø½á¹ûÕýÈ·, ²¢ÇÒ³¤¶ÈÎª24Î», 3×Ö½Ú,(1)¿¨ÄÚ´æ´¢Æ÷´óÐ¡+(2
             -)CRC
 413   1              {
 414   2              status = MI_ERR;                                                        // ´íÎó
 415   2              }
 416   1          return status;                                                                      // ·µ»Ø½á¹û
 417   1      }
 418          //*************************************************************************
 419          // º¯ÊýÃû       £ºPcdAnticoll
 420          // ÃèÊö         £º·À³å×²
 421          // Èë¿Ú         £ºpSnr[OUT]:¿¨Æ¬ÐòÁÐºÅ£¬4×Ö½Ú
 422          // ³ö¿Ú         £ºÎÞ
 423          // ·µ»Ø         £º³É¹¦·µ»ØMI_OK
C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 8   

 424          //*************************************************************************
 425          s8 PcdAnticoll(u8 *pSnr)
 426          {
 427   1          s8 status;
 428   1          u8 i,snr_check=0;
 429   1          u16  unLen;
 430   1          u8 ucComMF522Buf[MAXRLEN]; 
 431   1         
 432   1          ClearBitMask(Status2Reg,0x08);                      // Çå¿ÕÐ£Ñé³É¹¦±êÖ¾     
 433   1          WriteRawRC(BitFramingReg,0x00);                     // ×îºóÒ»¸ö×Ö½Ú·¢ËÍËùÓÐÊý¾Ý
 434   1          ClearBitMask(CollReg,0x80);                         // CollRegCollReg       0³åÍ»½áÊøºó³åÍ»Î»±»ÖÃÁã
 435   1       
 436   1              memset(ucComMF522Buf, 0x00, MAXRLEN);
 437   1              
 438   1          ucComMF522Buf[0] = PICC_ANTICOLL1;                  // ·À³åÍ»Ö¸Áî£¬ËùÓÐÎ»ÔÚ½ÓÊÕµ½³åÍ»ºó½«Çå³ý
 439   1          ucComMF522Buf[1] = 0x20;                                    // ·¢ËÍ2¸ö×Ö½Ú
 440   1      
 441   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
 442   1      
 443   1          if (status == MI_OK)                                                
 444   1          {
 445   2               for (i=0; i<4; i++)                                    // ½ÓÊÜ¿¨ID
 446   2               {   
 447   3                   *(pSnr+i)  = ucComMF522Buf[i];             // 0-3:ID
 448   3                   snr_check ^= ucComMF522Buf[i];             // Ð£ÑéID
 449   3               }
 450   2               if (snr_check != ucComMF522Buf[i])             // 4:Ð£ÑéÖµ
 451   2                       {       
 452   3                      status = MI_ERR;                                        // Ð£Ñé³ö´í
 453   3                       }
 454   2          }
 455   1              else
 456   1              {
 457   2                      status = MI_ERR;
 458   2              }
 459   1          SetBitMask(CollReg,0x80);                                   // CollRegCollReg       ÔÚ106kbpsÁ¼ºÃµÄ·À³åÍ»Çé¿öÏÂ¸ÃÎ»ÖÃ1
 460   1              return status;                                                          // ·µ»Ø½á¹û
 461   1      }
 462          //*************************************************************************
 463          // º¯ÊýÃû       £ºPcdRequest
 464          // ÃèÊö         £ºÑ°¿¨
 465          // Èë¿Ú         £ºreq_code[IN]:Ñ°¿¨·½Ê½, 0x52 = Ñ°¸ÐÓ¦ÇøÄÚËùÓÐ·ûºÏ14443A±ê×¼µÄ¿¨,0x26 = Ñ°Î´½øÈëÐÝÃß×´Ì¬µÄ¿¨
 466          //                       
 467          // ³ö¿Ú         £º pTagType[OUT]£º¿¨Æ¬ÀàÐÍ´úÂë
 468          //                            0x4400 = Mifare_UltraLight 
 469          //                            0x0400 = Mifare_One(S50)
 470          //                0x0200 = Mifare_One(S70)
 471          //                0x0800 = Mifare_Pro(X)CPU¿¨
 472          //                0x4403 = Mifare_DESFire
 473          // ·µ»Ø         £º³É¹¦·µ»ØMI_OK
 474          //*************************************************************************
 475          s8 PcdRequest(u8 req_code,u8 *pTagType)
 476          {
 477   1              s8 status =MI_ERR;  
 478   1              u16 unLen;
 479   1              u8 ucComMF522Buf[MAXRLEN]; 
 480   1      
 481   1              PcdReset();
 482   1              
 483   1              ClearBitMask(Status2Reg,0x08);                  // Çå¿ÕÐ£Ñé³É¹¦±êÖ¾,Çå³ýMFCrypto1OnÎ»
 484   1              WriteRawRC(BitFramingReg,0x07);                 // StartSend =0;RxAlign=0¶¨Òå×îºóÒ»¸ö×Ö½Ú·¢ËÍµÄÎ»Êý,·¢ËÍ7¸öÎ»
 485   1              SetBitMask(TxControlReg,0x03);                  // Á½ÌìÏß·¢ÉäÐÅºÅ,Tx1RFEn,Tx2RFEnÖÃ1
C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 9   

 486   1       
 487   1              memset(ucComMF522Buf, 0x00, MAXRLEN);
 488   1              
 489   1              ucComMF522Buf[0] = req_code;                            //Ñ°¿¨·½Ê½,ËùÓÐ¿¨»¹ÊÇÆäËûÊ²Ã´¿¨
 490   1      
 491   1              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);// ½«ÊÕµ½µÄ¿¨Æ¬ÀàÐÍºÅ±£´æ
 492   1      
 493   1              if(status == MI_OK)
 494   1              {
 495   2                      *pTagType     = ucComMF522Buf[0];
 496   2                      *(pTagType+1) = ucComMF522Buf[1];
 497   2              }        
 498   1              else
 499   1              {
 500   2                      status = MI_ERR;
 501   2              }
 502   1              return status;                                                          //·µ»Ø½á¹û
 503   1      }
 504          
 505          //*************************************************************************
 506          // º¯ÊýÃû       £ºPcdRats
 507          // ÃèÊö         £º×ªÈëAPDUÃüÁî¸ñÊ½
 508          // Èë¿Ú         £º ÎÞ
 509          // ³ö¿Ú         £º DataOut Êä³öµÄÊý¾Ý£¬ Len Êä³öÊý¾ÝµÄ³¤¶È
 510          // ·µ»Ø         £º³É¹¦·µ»ØMI_OK
 511          //*************************************************************************
 512          
 513          s8 PcdRats(u8 * DataOut,u8 * Len)
 514          {
 515   1              s8 status =MI_ERR;  
 516   1              u16 unLen;
 517   1              u8 ucComMF522Buf[MAXRLEN]; 
 518   1      
 519   1              ClearBitMask(Status2Reg,0x08);  // Çå¿ÕÐ£Ñé³É¹¦±êÖ¾,Çå³ýMFCrypto1OnÎ»
 520   1      
 521   1              memset(ucComMF522Buf, 0x00, MAXRLEN);
 522   1      
 523   1              ucComMF522Buf[0] = 0xE0;                
 524   1              ucComMF522Buf[1] = 0x51;                                
 525   1      
 526   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);     // Éú³É·¢ËÍÄÚÈÝµÄCRCÐ£Ñé,±£´æµ½×îºóÁ½¸ö×Ö½Ú
 527   1              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,DataOut,&unLen);// ½«ÊÕµ½µÄ¿¨Æ¬ÀàÐÍºÅ±£´æ
 528   1      
 529   1              if (status == MI_OK)
 530   1              {
 531   2                      Len[0]= unLen/8-2;
 532   2                      status = MI_OK;
 533   2              }        
 534   1              else
 535   1                      status = MI_ERR;         
 536   1              return status;                                                          //·µ»Ø½á¹û
 537   1      }
 538          
 539          //*************************************************************************
 540          // º¯ÊýÃû       £ºGetCard()
 541          // ÃèÊö         £ºIC¿¨¼ì²â,²¢·µ»ØÊý¾Ý
 542          // Èë¿Ú         £ºreq_code[IN]:Ñ°¿¨·½Ê½, 0x52 = Ñ°¸ÐÓ¦ÇøÄÚËùÓÐ·ûºÏ14443A±ê×¼µÄ¿¨,0x26 = Ñ°Î´½øÈëÐÝÃß×´Ì¬µÄ¿¨
 543          // ³ö¿Ú         £ºpTagType[OUT]£º¿¨Æ¬ÀàÐÍ´úÂë
 544          //                              0x4400 = Mifare_UltraLight 
 545          //                              0x0400 = Mifare_One(S50)
 546          //                      0x0200 = Mifare_One(S70)
 547          //                      0x0800 = Mifare_Pro(X)
C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 10  

 548          //                      0x4403 = Mifare_DESFire
 549          //                                      snr[OUT]:IC¿¨ID
 550          // ·µ»Ø         £º³É¹¦·µ»Ø ST_OK
 551          //*************************************************************************
 552          u16 GetCard(u8 Reqcode, u8* pTagType, u8* pSnr)
 553          {
 554   1              s8 status ;
 555   1              status = PcdRequest(Reqcode, pTagType);                                 //Ñ°¿¨
 556   1              if(status)
 557   1              {
 558   2                      status = PcdRequest(Reqcode, pTagType);
 559   2      
 560   2                      if(status)
 561   2                      {
 562   3                              return ST_ERR;
 563   3                      }
 564   2              }
 565   1      
 566   1              status = PcdAnticoll(pSnr);                                                             //·À³å×², »ñÈ¡ID
 567   1              if(status)
 568   1              {
 569   2                      return ST_ERR;
 570   2              }
 571   1      
 572   1              status = PcdSelect(pSnr);                                                               //Ñ¡Ôñ¿¨Æ¬
 573   1              if(status)
 574   1              {
 575   2                      return ST_ERR;
 576   2              }
 577   1              return ST_OK;
 578   1      
 579   1      }
 580          //*************************************************************************
 581          // º¯ÊýÃû       £ºCpuReset()
 582          // ÃèÊö         £ºCPU¿¨×¨ÓÃ¸´Î»
 583          // Èë¿Ú         £ºÎÞ
 584          // ³ö¿Ú         £ºData_Out Êä³öµÄ¸´Î»Êý¾ÝÐÅÏ¢¼°³¤¶È
 585          // ·µ»Ø         £º³É¹¦·µ»Ø9000
 586          //*************************************************************************
 587          
 588          u16 CardReset(u8 * Data_Out,u8 *  Len)
 589          {
 590   1              s8 status = MI_OK;      
 591   1              status = PcdRats(Data_Out,Len);                                                                         //¿¨Æ¬¸´Î»
 592   1              if(status)
 593   1              {
 594   2                      return ST_ERR;
 595   2              }
 596   1              else
 597   1      
 598   1                      return ST_OK;
 599   1              
 600   1      }
 601          
 602          
 603          
 604          
 605          //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -/////////////////////// 
 606          //*************************************************************************
 607          // º¯ÊýÃû       £ºPcd_Cmd
 608          // ÃèÊö         £ºÖ´ÐÐÉÏÎ»»ú·¢À´µÄÖ¸Áî
C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 11  

 609          // Èë¿Ú         £ºpDataIn : ÒªÖ´ÐÐµÄÖ¸Áî In_Len  Ö¸ÁîÊý¾Ý³¤¶È                                   
 610          // ³ö¿Ú         £ºpDataOut£ºÊä³öÖ´ÐÐºóµÄ·µ»ØÊý¾Ý   Out_LenÊä³öµÄÊý¾Ý³¤¶È
 611          // ·µ»Ø         £ºMI_OK
 612          //*************************************************************************
 613           
 614          u8 Pcd_Cmd(u8* pDataIn, u8  In_Len, u8* pDataOut,u8 * Out_Len)
 615          {
 616   1              s8 status =MI_ERR;  
 617   1              u16 unLen;
 618   1              u8 ucComMF522Buf[MAXRLEN]; 
 619   1              u8 i;
 620   1      
 621   1              ClearBitMask(Status2Reg,0x08);                                  // Çå¿ÕÐ£Ñé³É¹¦±êÖ¾,Çå³ýMFCrypto1OnÎ»
 622   1              memset(ucComMF522Buf, 0x00, MAXRLEN);
 623   1      
 624   1              PcdSwitchPCB();
 625   1              
 626   1              ucComMF522Buf[0] = PCB;
 627   1              ucComMF522Buf[1] = 0x01;
 628   1      
 629   1      
 630   1              ucComMF522Buf[2] = pDataIn[0];                          // CLA
 631   1              ucComMF522Buf[3] = pDataIn[1];                          // INS                  
 632   1              ucComMF522Buf[4] = pDataIn[2];                          // P1                                            
 633   1              ucComMF522Buf[5] = pDataIn[3];                          // P2                                   
 634   1              ucComMF522Buf[6] = pDataIn[4];                          // LEN  
 635   1              Hex_Print(In_Len);
 636   1              Hex_Print(ucComMF522Buf[0]);
 637   1              Hex_Print(ucComMF522Buf[1]);
 638   1              Hex_Print(ucComMF522Buf[2]);
 639   1              Hex_Print(ucComMF522Buf[3]);
 640   1              Hex_Print(ucComMF522Buf[4]);
 641   1              Hex_Print(ucComMF522Buf[5]);
 642   1              Hex_Print(ucComMF522Buf[6]);
 643   1              
 644   1              Send_char1('\r');
 645   1              Send_char1('\n');
 646   1      
 647   1              for(i=0;i<ucComMF522Buf[6];i++)                         //DATA
 648   1              {
 649   2                      ucComMF522Buf[7+i] = pDataIn[5+i];        
 650   2      
 651   2              }
 652   1                                                                                      
 653   1          CalulateCRC(ucComMF522Buf,In_Len+2,&ucComMF522Buf[In_Len+2]);       // Éú³É·¢ËÍÄÚÈÝµÄCRCÐ£Ñé,±£´æµ½×îºóÁ½¸ö×
             -Ö½Ú
 654   1              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,In_Len+4,pDataOut,&unLen);                                                    
 655   1              if (status == MI_OK)
 656   1              {
 657   2                      Out_Len[0] = unLen/8-4;  //½ÓÊÕµ½Êý¾ÝµÄ³¤¶È,²»ÒªÇ°ÃæºÍºóÃæµÄ¸÷Á½¸ö×Ö½Ú£¬²ÅÊÇ·µ»ØµÄÓÐÓÃÊý¾Ý                                              
 658   2                      return MI_OK;
 659   2              }
 660   1              else
 661   1              {
 662   2                  Out_Len[0] = unLen/8-4;
 663   2                      if((pDataOut[2]==0x90)&&(pDataOut[3]==0x00))
 664   2                      return MI_OK;
 665   2                      else
 666   2                      return MI_ERR;
 667   2      
 668   2              }
 669   1      
C51 COMPILER V9.54   RC522                                                                 03/18/2019 10:28:34 PAGE 12  

 670   1      }
 671          
 672          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2335    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1     397
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =      1    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
